#+title: Tenzing

* Introduction
  Tenzing is a library for managing identity in mutable grids. The chief
  example of an application wich such grids is a spreadsheet, where rows and
  columns can be inserted, removed and moved around. Tenzing provides identity
  for grid cells, so that data, dependencies and other properties can be
  attached to them.

* Public API

  + ~(make-chart options)~ Constructs a multi-dimensional chart. If
    ~dimensions~ are supplied, dimensions are named after them, otherwise
    anonymous. Iff anonymous, their number is defined by ~dimensionality~. The
    ~encode~ / ~decode~ functions convert cell origins to/from IDs (both
    default to ~identity~).

  + ~(cell->node cell chart)~ Returns the node for ~cell~ according to
    ~chart~.

  + ~(node->cell node chart)~ Returns the cell for ~node~ according to
    ~chart~, ~nil~ if not visible.

  + ~(slice-nodes->cells slice)~ Returns the cells of ~slice~' (a map
    containing ~:start~ and ~:end~ nodes) according to ~chart~.

  + ~(operate chart dimension operation)~ Performs ~operation~ on the
    ~dimension~ in ~chart~. For charts with named dimensions, ~dimension~ is a
    name, otherwise an index. Discards any previously undone operations.

  + ~(undo chart)~ Deactivates the last active operation in ~chart~, if any.

  + ~(redo chart)~ Reactivates the last deactivated operation in ~chart~, if
    any.

  + ~(make-transformers operation)~ Multimethod (dispatched on ~operation~'s
    ~:action~) for extending the operation set.

* Introduction

  For a common 2D spreadsheet grid, we could define a chart like this:
  #+BEGIN_SRC clojure :exports code :results silent
(require '[clojure.edn :as edn]
	 '[tenzing.core :as tz])

(def spreadsheet-chart (tz/make-chart {:dimensions [:row :column]}))
  #+END_SRC

  Then, we can start asking for cell identities:
  #+BEGIN_SRC clojure :exports code :results silent
(def id-1 (tz/cell->id [3 4] spreadsheet-chart))
(def id-2 (tz/cell->id [13 14] spreadsheet-chart))
  #+END_SRC

  #+BEGIN_SRC clojure :exports both :results value verbatim
(map #(tz/id->cell % spreadsheet-chart) [id-1 id-2])
  #+END_SRC

  #+RESULTS:
  : ([3 4] [13 14])

  Tenzing supports three actions as grid operations out of the box: insertion
  (~:insert~ ~:count~ cells at ~:index~), removal (~:remove~ ~:count~
  consecutive cells starting at ~:index~) and transposition (~:transpose~
  ~:count~ consecutive cells starting at ~:index~ ~:offset~ positions to the
  right -- a negative ~:offset~ meaning to the left).

** Insertion

   Let's insert 3 new consecutive rows, with the first new one at position 10:
   #+BEGIN_SRC clojure :exports both :results value verbatim
(as-> spreadsheet-chart $
  (tz/operate $ :row {:action :insert :index 10 :count 3})
  (map #(tz/id->cell % $) [id-1 id-2]))
   #+END_SRC

   #+RESULTS:
   : ([3 4] [16 14])
   Notice how the cell corresponding to ~node-1~ wasn't affected, but the one
   for ~node-2~ was moved 3 positions down. Thus, the slice between them has
   grown:
   #+BEGIN_SRC clojure :exports both :results value verbatim
{:before (-> {:start id-1 :end id-2}
	     (tz/slice-ids->cells spreadsheet-chart)
	     count)
 :after  (as-> spreadsheet-chart $
	   (tz/operate $ :row {:action :insert :index 10 :count 3})
	   (tz/slice-ids->cells {:start id-1 :end id-2} $)
	   (count $))}
   #+END_SRC

   #+RESULTS:
   : {:before 121, :after 154}

** Removal

   Let's remove 3 consecutive columns starting from position 10:
   #+BEGIN_SRC clojure :exports both :results value verbatim
(as-> spreadsheet-chart $
  (tz/operate $ :column {:action :remove :index 10 :count 3})
  (map #(tz/id->cell % $) [id-1 id-2]))
   #+END_SRC

   #+RESULTS:
   : ([3 4] [13 11])
   Notice that, again, the cell corresponding to ~node-1~ wasn't affected, but
   the one for ~node-2~ was moved 3 positions to the left. Thus, the slice
   between them has shrunk:
   #+BEGIN_SRC clojure :exports both :results value verbatim
{:before (-> {:start id-1 :end id-2}
	     (tz/slice-ids->cells spreadsheet-chart)
	     count)
 :after  (as-> spreadsheet-chart $
	   (tz/operate $ :column {:action :remove :index 10 :count 3})
	   (tz/slice-ids->cells {:start id-1 :end id-2} $)
	   (count $))}
   #+END_SRC

   #+RESULTS:
   : {:before 121, :after 88}

** Transposition

   Let's transpose 3 consecutive rows, starting from position 2, one position
   up (notice the negative ~:offset~ value)
   #+BEGIN_SRC clojure :exports both :results value verbatim
(as-> spreadsheet-chart $
  (tz/operate $ :row {:action :transpose :index 2 :count 3 :offset -1})
  (map #(tz/id->cell % $) [id-1 id-2]))
   #+END_SRC

   #+RESULTS:
   : ([2 4] [13 14])
   Notice that, this time, the cell corresponding to ~node-2~ wasn't affected,
   whereas the one for ~node-1~ was indeed moved one position up (as it
   belonged to the rows being transposed). Thus, the slice between them has
   grown:
   #+BEGIN_SRC clojure :exports both :results value verbatim
{:before (-> {:start id-1 :end id-2}
	     (tz/slice-ids->cells spreadsheet-chart)
	     count)
 :after  (as-> spreadsheet-chart $
	   (tz/operate $ :row {:action :transpose :index 2 :count 3 :offset -1})
	   (tz/slice-ids->cells {:start id-1 :end id-2} $)
	   (count $))}
   #+END_SRC

   #+RESULTS:
   : {:before 121, :after 132}

** Undo/redo

   Tenzing supports linear undo/redo, the scheme most popular among end-user
   applications. What this means is that we can at any time undo the last
   active operation. Any undone operation may be redone (i.e. re-activated),
   provided that no other operations have been applied since the undo. In
   other words, every new operation truncates history of operations that were
   undone at the time of its introduction. Let's see it in action (observing
   the position of ~node-2~ during a simple chain of undos and redos):
   #+BEGIN_SRC clojure :exports both :results value verbatim
(loop [chart  (-> spreadsheet-chart
		  (tz/operate :row {:action :insert :index 10 :count 3})
		  (tz/operate :column {:action :remove :index 10 :count 3}))
       ;; notice the extraneous third undo (nop)
       ops    [tz/undo tz/undo tz/undo tz/redo tz/redo]
       result [(tz/id->cell id-2 chart)]]
  (if-not (seq ops) result
	  (let [new-chart ((first ops) chart)]
	    (recur new-chart
		   (rest ops)
		   (conj result (tz/id->cell id-2 new-chart))))))
   #+END_SRC

   #+RESULTS:
   : [[16 11] [16 14] [13 14] [13 14] [16 14] [16 11]]
   Extraneous undos (when there no more active operations) and redos (when
   there have been no undos since the last operation) have no effect.

** Extensibility

   Tenzing supports extension of its operation set. To add a new operation, you
   have to define a method for the ~make-transformers~ multimethod. Its input
   is a map with no requirements but a unique dispatch (~:action~) value. The
   method should return a map of two functions:

   + ~(descend pos & [bypass]))~ Returns the old position of the cell at
     position ~pos~ after the operation. If it was just inserted, return
     ~nil~, unless the optional ~bypass~ direction (either ~:min~ or ~:max~)
     is specified. In this case, return the position of the nearest available
     cell in that direction before the operation is performed.

   + ~(ascend pos & [bypass]))~ Returns the new position of the cell that was
     at position ~pos~ before the operation. If it was just removed, return
     ~nil~, unless the optional ~bypass~ direction (either ~:min~ or ~:max~)
     is specified. In this case, return the position of the nearest available
     cell in that direction after the operation is performed.

   For example, suppose we want to define an operation which creates a double
   of every cell along a dimension (to create, for example, a column on the
   right of each column in a spreadsheet). We can define such an operation by
   writing something like this:
   #+BEGIN_SRC clojure :exports code :results silent
(defmethod tz/make-transformers :interpose [_op]
  {:descend (fn [pos & [bypass]]
	      (if (even? pos) (/ pos 2)
		  (get {:min (dec pos)
			:max (inc pos)}
		       bypass)))
   :ascend  (fn [pos & _] (* pos 2))})
   #+END_SRC
   We can now see the new operation in action:
   #+BEGIN_SRC clojure :exports both :results value verbatim
(as-> spreadsheet-chart $
  (tz/operate $ :column {:action :interpose})
  (map #(tz/id->cell % $) [id-1 id-2]))
   #+END_SRC

   #+RESULTS:
   : ([3 8] [13 28])
   Of course, if we ask for the position of a cell created by the operation
   after we undo it, we get ~nil~:
   #+BEGIN_SRC clojure :exports both :results value verbatim
(let [interposed (tz/operate spreadsheet-chart :column {:action :interpose})]
  (tz/id->cell (tz/cell->id [3 3] interposed)
               (tz/undo interposed)))
   #+END_SRC

   #+RESULTS:
   : nil
   For other cells, we get their old position as usual:
   #+BEGIN_SRC clojure :exports both :results value verbatim
(let [interposed (tz/operate spreadsheet-chart :column {:action :interpose})]
  (tz/id->cell (tz/cell->id [3 4] interposed)
               (tz/undo interposed)))
   #+END_SRC

   #+RESULTS:
   : [3 2]
